<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Traps on Go 语言必知必会</title>
    <link>https://golang.dbwu.tech/traps/</link>
    <description>Recent content in Traps on Go 语言必知必会</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 01 Jan 2023 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://golang.dbwu.tech/traps/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title></title>
      <link>https://golang.dbwu.tech/traps/array_with_map_in_params/</link>
      <pubDate>Sun, 01 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://golang.dbwu.tech/traps/array_with_map_in_params/</guid>
      <description>概述 虽然切片的底层是数组，但是当切片和数组作为函数的参数时，规则是不一样的。
数组传值不会改变原数组 错误的做法 package main import &amp;#34;fmt&amp;#34; func double(arr [5]int) { for i := range arr { arr[i] *= 2 } } func main() { numbers := [...]int{1, 2, 3, 4, 5} for i := range numbers { fmt.Printf(&amp;#34;%v &amp;#34;, numbers[i]) } double(numbers) fmt.Println() for i := range numbers { fmt.Printf(&amp;#34;%v &amp;#34;, numbers[i]) } } // $ go run main.go // 输出如下 /** 1 2 3 4 5 1 2 3 4 5 */ 从输出结果中看到，数值元素的值并没有被修改。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://golang.dbwu.tech/traps/buffer_flush/</link>
      <pubDate>Sun, 01 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://golang.dbwu.tech/traps/buffer_flush/</guid>
      <description>概述 bufio 包实现了 缓冲 IO，它通过在内部封装一个 io.Reader 或 io.Writer 来实现具体的读写操作。 通过 缓冲 IO 可以大大提升 IO 操作的性能，但是有时候，缓冲区也会带来一些违反直觉的问题。
下面的这个小案例是笔者在真实项目中遇到的，整理一下，分享给大家。
错误的做法 package main import ( &amp;#34;bufio&amp;#34; &amp;#34;fmt&amp;#34; &amp;#34;os&amp;#34; ) func main() { _, err := fmt.Fprintf(os.Stdout, &amp;#34;%s\n&amp;#34;, &amp;#34;[unbuffered] hello world&amp;#34;) if err != nil { panic(err) } buf := bufio.NewWriter(os.Stdout) _, err = fmt.Fprintf(buf, &amp;#34;%s\n&amp;#34;, &amp;#34;[buffered] hello world&amp;#34;) // 不会输出 	if err != nil { panic(err) } } // $ go run main.go // 输出如下 /** [unbuffered] hello world */ 通过输出的结果可以看到，缓冲区数据并没有刷出。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://golang.dbwu.tech/traps/byte_operation/</link>
      <pubDate>Sun, 01 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://golang.dbwu.tech/traps/byte_operation/</guid>
      <description>概述 标准库中的 byte 类型是 uint8 类型的别名，在所有方面都相当于 uint8，主要作用是用来区分字节类型和无符号整数类型。
两个 byte 值使用 + 相加，并不会产生 字符拼接 的效果形成字符串，相反，会先将两个 byte 值转换成对应的无符号整数类型， 然后进行相加，最后的结果是一个整数。
例子 错误的做法 package main import &amp;#34;fmt&amp;#34; func main() { a, b := &amp;#39;a&amp;#39;, &amp;#39;b&amp;#39; c := a + b fmt.Printf(&amp;#34;a type = %T, val = %v\n&amp;#34;, a, a) fmt.Printf(&amp;#34;b type = %T, val = %v\n&amp;#34;, b, a) fmt.Printf(&amp;#34;c type = %T, val = %v\n&amp;#34;, c, c) } $ go run main.go # 输出如下 a type = int32, val = 97 b type = int32, val = 97 c type = int32, val = 195 通过输出结果可以看到，字符 a + b 没有得到预料之中的结果 ab, 而是先分别将 a 和 b 转换为数字 97, 98，然后相加得到结果 195。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://golang.dbwu.tech/traps/channel_not_closed/</link>
      <pubDate>Sun, 01 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://golang.dbwu.tech/traps/channel_not_closed/</guid>
      <description>通道为 nil 造成 goroutine 泄漏 在 nil 通道 上发送和接收操作将永久阻塞，造成 goroutine 泄漏。
 最佳实践: 1. 永远不要对 nil 通道 进行任何操作，2. 直接使用 make() 初始化通道。
 接收造成的泄漏 示例代码只是为了演示，没有任何实际意义。
package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func main() { var ch chan bool go func() { defer func() { // defer 不会执行 	fmt.Println(&amp;#34;goroutine ending&amp;#34;) // 不会输出 	}() for v := range ch { fmt.Println(v) } fmt.Println(&amp;#34;range broken&amp;#34;) // 执行不到这里 	}() time.Sleep(time.Second) // 假设主程序 1 秒后退出 } // $ go run main.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://golang.dbwu.tech/traps/copy/</link>
      <pubDate>Sun, 01 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://golang.dbwu.tech/traps/copy/</guid>
      <description>概述 copy 函数可以将一个切片里面的元素拷贝至另外一个切片，函数的原型如下:
func copy(dst []Type, src []Type) int 将切片 src 里面的元素拷贝至切片 dst, 返回拷贝成功的元素数量。需要注意的一点是，copy 函数默认切片 dst 有足够的容量存放拷贝的元素， 如果容量不足的话，那么切片 src 中超过 dst 容量长度的元素将不再拷贝。
错误的做法 package main import &amp;#34;fmt&amp;#34; func main() { var src, dst []int src = []int{1, 2, 3} n := copy(dst, src) fmt.Printf(&amp;#34;the number of copied elements is %d\n&amp;#34;, n) fmt.Printf(&amp;#34;dst = %v\n&amp;#34;, dst) } $ go run main.go # 输出如下 the number of copied elements is 0 dst = [] 从输出结果中看到，返回拷贝成功的元素数量为 0, 变量 dst 依然是一个空切片，错误的原因在于: 变量 dst 没有容量来存放变量 src 的元素。 接下来，我们修正这个错误。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://golang.dbwu.tech/traps/defer_exam/</link>
      <pubDate>Sun, 01 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://golang.dbwu.tech/traps/defer_exam/</guid>
      <description>test-1 package main func foo(n int) (t int) { t = n defer func() { t += 3 }() return t } func main() { println(foo(1)) } 上面的代码会输出什么？思考之后 &amp;hellip;
$ go run main.go # 输出如下 4 结果分析 package main func foo(n int) (t int) { ①t = n // 此时 t 为 1 	②defer func() { ④	t += 3 // 此时 t 为 4, 因为 t 是命名返回值，所以返回 4 	}() ③return t // 此时 t 为 1 } func main() { println(foo(1)) // 调用函数 foo(), 参数为 1 } test-2 package main func foo(n int) int { t := n defer func() { t += 3 }() return t } func main() { println(foo(1)) } 上面的代码会输出什么？思考之后 &amp;hellip;</description>
    </item>
    
    <item>
      <title></title>
      <link>https://golang.dbwu.tech/traps/defer_with_recover/</link>
      <pubDate>Sun, 01 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://golang.dbwu.tech/traps/defer_with_recover/</guid>
      <description>defer defer 语句经常用于成对的操作，比如 打开文件/关闭文件 连接网络/断开网络, 合理地使用 defer 不仅可以提高代码可读性，也降低了忘记释放资源造成的泄漏等问题。
正确使用 defer 语句的地方是在成功获取资之后。
断开网络连接 package main import ( &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; ) func main() { resp, err := http.Get(&amp;#34;https://www.baidu.com&amp;#34;) // 此时资源有可能获取失败，执行 Close 导致 panic 	// resp.Body.Close() 	if err != nil { panic(err) } defer func() { err = resp.Body.Close() // 关闭资源 	if err != nil { log.Fatal(err) } }() } 关闭文件句柄 package main import ( &amp;#34;os&amp;#34; ) func main() { name := &amp;#34;/etc/hosts&amp;#34; file, err := os.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://golang.dbwu.tech/traps/for_assign/</link>
      <pubDate>Sun, 01 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://golang.dbwu.tech/traps/for_assign/</guid>
      <description>循环赋值错误 错误的做法 package main import &amp;#34;fmt&amp;#34; func main() { number := make([]int, 5) for i, v := range number { v = i fmt.Printf(&amp;#34; %v&amp;#34;, v) } fmt.Println(&amp;#34;\n&amp;#34;, number) } // $ go run main.go // 输出如下 /** 0 1 2 3 4 [0 0 0 0 0] */ 错误的原因在于: 循环时的 v 变量是从当前元素复制出来的一个临时变量，修改它的值并不会影响到当前元素的值。
正确的做法 package main import &amp;#34;fmt&amp;#34; func main() { number := make([]int, 5) for i, _ := range number { number[i] = i fmt.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://golang.dbwu.tech/traps/for_func/</link>
      <pubDate>Sun, 01 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://golang.dbwu.tech/traps/for_func/</guid>
      <description>循环调用 defer 错误 defer 在函数退出时才会执行，在循环中执行 defer 释放资源时，由于延迟可能会引发 资源泄露问题。
错误的做法 package main import ( &amp;#34;log&amp;#34; &amp;#34;os&amp;#34; ) func main() { for i := 0; i &amp;lt; 5; i++ { f, err := os.Open(&amp;#34;/path/to/file&amp;#34;) if err != nil { log.Fatal(err) } defer f.Close() } zero := 0 println(1 / zero) // 程序执行到这里异常退出，那么上面的循环中打开的 5 个文件句柄全部无法泄露 } 错误的原因在于: 极端情况下（比如 for 循环执行完程序异常，或者 for 还没执行完程序异常），将导致所有文件句柄无法释放，造成资源泄露。
再比如在第 4 次循环的时候，打开文件报错了，接着调用 log.Fatal(err) 结束程序，这时候，前面 3 次循环打开的 3 个文件句柄资源无法被释放，造成资源泄露。
正确的做法 解决的方法: 可以在 for 中构造一个局部函数，然后在局部函数内执行 defer 函数释放资源， 这样即使极端情况下程序异常退出，但是已经打开的文件句柄已经全部被释放，不会造成资源泄露。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://golang.dbwu.tech/traps/for_goroutine/</link>
      <pubDate>Sun, 01 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://golang.dbwu.tech/traps/for_goroutine/</guid>
      <description>循环中 goroutine 执行顺序不一致 错误的做法 package main import &amp;#34;sync&amp;#34; func main() { var wg sync.WaitGroup for i := 0; i &amp;lt; 5; i++ { wg.Add(1) go func(n int) { defer wg.Done() println(n) }(i) } wg.Wait() } // $ go run main.go // 输出如下，顺序是乱序的，你的输出可能和这里的不一样，可以多试几次，看看效果 /** 5 1 4 2 3 */ 错误的原因在于: 虽然 goroutine 是在循环中顺序启动的，但是其执行是并发的 (开始和结束时间不一定)，所以最终输出的结果中，也是乱序的。
正确的做法 知道错误的原因后，一个简单的解决方案是: 使用通道保证 goroutine 是顺序执行的，这样最终的输出结果一定是顺序的。
package main import ( &amp;#34;sync&amp;#34; ) func main() { var wg sync.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://golang.dbwu.tech/traps/goroutine_race/</link>
      <pubDate>Sun, 01 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://golang.dbwu.tech/traps/goroutine_race/</guid>
      <description>main 结束时不考虑 goroutine 执行状态 默认情况下，主程序结束时不会考虑当前是否还有 goroutine 正在执行。
错误的做法 package main import ( &amp;#34;fmt&amp;#34; &amp;#34;time&amp;#34; ) func main() { for i := 0; i &amp;lt; 3; i++ { go func() { defer func() { fmt.Println(&amp;#34;goroutine ending&amp;#34;) }() time.Sleep(100 * time.Millisecond) // 模拟耗时操作 	}() } fmt.Println(&amp;#34;main ending&amp;#34;) } // $ go run main.go // 输出如下 /** main ending */ 从输出结果中看到，只有 main() 输出的字符串， 3 个 goroutine 没有输出任何字符串。
正确的做法 使用 sync.WaitGroup 同步原语 保证主程序结束前所有 goroutine 正常退出。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://golang.dbwu.tech/traps/interface_error/</link>
      <pubDate>Sun, 01 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://golang.dbwu.tech/traps/interface_error/</guid>
      <description>概述 interface{} 类型可以表示任意数据类型，直觉上来看，当然也可以表示 *interface 类型。 那么两者之间可以直接转换吗？我们通过两个小例子来验证一下。
例子 interface{} 不能直接转换为 *interface package main // 参数为 interface func foo(x interface{}) { } // 参数为 *interface func bar(x *interface{}) { } func main() { s := &amp;#34;&amp;#34; // s 类型为字符串 	p := &amp;amp;s // p 类型为字符串指针  foo(s) // ok, interface{} 可以表示字符串 	bar(s) // error, *interface 无法表示字符串  foo(p) // ok, interface{} 可以表示字符串指针 	bar(p) // error, *interface 无法表示字符串指针 } $ go run main.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://golang.dbwu.tech/traps/interface_method/</link>
      <pubDate>Sun, 01 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://golang.dbwu.tech/traps/interface_method/</guid>
      <description>概述 接口方法调用时，调用方必须和接口方法定义的接收者类型相同或者可以通过推导得到。
具体的规则:
 接收者为值的方法，可以通过值类型变量调用 接收者为值的方法，可以通过指针类型变量调用，因为指针可以被解引用得到值类型 接收者为指针的方法，可以通过指针类型变量调用 接收者为指针的方法，不可以通过值类型变量调用  示例 接收者和调用方都是值类型 package main import ( &amp;#34;fmt&amp;#34; ) type Person interface { Name() string Age() int } type Martian struct { } // 接收者为值类型 func (m Martian) Name() string { return &amp;#34;martian&amp;#34; } // 接收者为值类型 func (m Martian) Age() int { return 0 } func main() { var m Person = Martian{} // 调用方为值类型 	fmt.Printf(&amp;#34;name is %s, age is = %d\n&amp;#34;, m.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://golang.dbwu.tech/traps/map_struct_assign/</link>
      <pubDate>Sun, 01 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://golang.dbwu.tech/traps/map_struct_assign/</guid>
      <description>未初始化时导致的报错 当 map 声明后但是未初始时，可以获取元素 (虽然获取不到)，但是无法修改元素 (会导致报错)。
map 未初始化时导致的报错 package main import &amp;#34;fmt&amp;#34; func main() { var m map[string]int // 获取元素不报错 	if v, ok := m[&amp;#34;zero&amp;#34;]; ok { fmt.Printf(&amp;#34;v = %v\n&amp;#34;, v) } else { fmt.Println(&amp;#34;element not exist&amp;#34;) } m[&amp;#34;zero&amp;#34;] = 0 // 修改元素报错 } // $ go run main.go // 输出如下 /** element not exist panic: assignment to entry in nil map ... ... exit status 2 */  最佳实践: 直接使用 make 声明并初始化 map 。</description>
    </item>
    
    <item>
      <title></title>
      <link>https://golang.dbwu.tech/traps/nil_argument/</link>
      <pubDate>Sun, 01 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://golang.dbwu.tech/traps/nil_argument/</guid>
      <description>概述 nil 可以作为函数参数传入，这意味着函数内部逻辑处理时，不能依赖于传入的实参 (有可能是 nil)， 一定要做必要的 零值 判断。
例子 示例代码只是为了演示，没有任何实际意义。
参数类型为切片 当 切片 为 nil 时，直接读取和赋值都会 panic 。
错误的做法 package main // 计算前 N 个数总和 func sumTopN(numbers []int, n int) int { total := 0 for _, v := range numbers[:n] { total += v } return total } func main() { println(sumTopN(nil, 3)) } // $ go run main.go // 输出如下 /** panic: runtime error: slice bounds out of range [:3] with capacity 0 goroutine 1 [running]: .</description>
    </item>
    
    <item>
      <title></title>
      <link>https://golang.dbwu.tech/traps/nil_with_nil/</link>
      <pubDate>Sun, 01 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://golang.dbwu.tech/traps/nil_with_nil/</guid>
      <description>概述 interface 类型数据结构内部实现包含 2 个字段， 类型 Type 和 值 Value。
 一个接口只有 Type == nil 并且 Value == unset 状态，该接口才等于 nil 。
比较规则:
 两个 接口值 进行比较时，先比较 Type，再比较 Value 接口值 与 非接口值 进行比较时，先将 非接口值 转换为 接口值，然后再进行比较  两个 nil 可能不相等 package main import ( &amp;#34;fmt&amp;#34; ) func main() { var p *int = nil var v interface{} = p // 赋值完成 	fmt.Println(v == p) // true 	fmt.Println(p == nil) // true 	fmt.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://golang.dbwu.tech/traps/slice_occupy_memory/</link>
      <pubDate>Sun, 01 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://golang.dbwu.tech/traps/slice_occupy_memory/</guid>
      <description>概述 切片的底层数据结构是数组，同样，切片的子切片会引用同样的数组。如果切片不主动不释放的话，那么底层的数组就会一直占用着内存。
切片返回值占用了整个数组 示例代码只是为了演示，没有任何实际意义。
错误的做法 package main import &amp;#34;fmt&amp;#34; func getFirstThreeNumber() []byte { res := make([]byte, 1000) fmt.Println(len(res), cap(res)) return res[:3] } func main() { res := getFirstThreeNumber() fmt.Println(len(res), cap(res)) } // $ go run main.go // 输出如下 /** 1000 1000 3 1000 */ 从输出结果中可以看到，即使函数已经返回切片，但是切片底层的数组一直被占用着，没有释放掉，浪费了很多内存。
正确的做法 分配一个合适大小的切片作为函数的返回值，这样函数返回后，切片底层的数组就会被释放掉。
package main import &amp;#34;fmt&amp;#34; func getFirstThreeNumber() []byte { data := make([]byte, 1000) fmt.Println(len(data), cap(data)) res := make([]byte, 3) copy(res, data[:3]) return res } func main() { res := getFirstThreeNumber() fmt.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://golang.dbwu.tech/traps/string_method/</link>
      <pubDate>Sun, 01 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://golang.dbwu.tech/traps/string_method/</guid>
      <description>概述 通常我们会对某个对象自定义一些方法，大多数情况下，这没有任何问题。但是有一种情况需要注意下，那就是自定义的 String 方法。
Go 标准库中有一个 Stringer 接口，原型如下:
type Stringer interface { String() string } 文件路径为 $GOROOT/src/fmt/print.go，笔者的 Go 版本为 go1.19 linux/amd64。
如果某个对象实现了自定义 String 方法，那么等于实现了 Stringer 接口。 如果在方法内部实现中调用了 fmt.Prinf* 系列方法，会导致错误。
内存溢出 错误的做法 package main import ( &amp;#34;fmt&amp;#34; ) type number int func (n number) String() string { return fmt.Sprintf(&amp;#34;%v&amp;#34;, n) } func main() { var n number = 100 println(n.String()) } // $ go run main.go // 没有任何输出，阻塞住，内存耗尽... 错误原因: 类型 number 自定义 String 方法实现了 Stringer 接口，方法内部调用了 fmt.</description>
    </item>
    
  </channel>
</rss>